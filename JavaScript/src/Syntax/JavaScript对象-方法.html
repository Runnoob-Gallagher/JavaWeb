<!DOCTYPE html>
<!--    Function对象：    方法对象
        1.创建：
            * var fun = new Function(形势参数列表,方法体);
            * function 方法名称(形势参数列表){
                方法体;
                }
            * var 方法名称 = function(方法的形势参数列表){
                方法体;
            }    如何印证它是对象：  调用它的属性     或者 像对象一样去再次赋值
        2.方法：
        3.属性：
            length: 表示形参的个数
        4.特点：
            方法定义时，形势参数的类型不用写，反正都是var
            方法是一个对象，如果定义名称相同的方法，会将前面的覆盖
            在JS中，方法的调用只与方法的名称有关，有参数列表的个数无关  如果是java的话，就是不行的。相当于没有匹配上，会提示报错  就是在调用方式时，不太注重形参
            在方法声明中有一个隐藏的内置对象（数组）arguements,封装所有的时间参数。  具体看例子
        5.调用：
            方法名称(实际参数列表);-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>对象</title>
    <script>
        var funA = new Function("a","b","c","alert(a + b + c)");
        //调用方法
        funA(3,4,5);

        function funB(a, b) {
            alert(a*b);
        }
        funB(3,6);

        var funC = function(va1,va2){
            alert(va1 / va2);
        }
        funC(10,2);

        //印证它是对象
        alert(funA.length + "   证明我是对象，我把对象的属性打印出来了")

        function funD(a,b,c,d) {
            alert(a);
            alert(b);
            alert(c);
            alert(d);
        }
        //funD(1); /*输出：  1,undefined,undefined,undefined*/
        //funD(1,2,3,4); /*输出： 1 2 3 4*/
        funD(1,2,3,4,5,6,7,8) /*只输出 1 2 3 4  后面的相当于没有*/

        function funE() {
            alert(arguments[0]);
            alert(arguments[1]);
        }
        funE(1,2);
        //当你想有无数个参数时，因为arguements是一个数组，数组就有长度，所以：
        function funF() {
            var sum = 0;
            for(var i = 0; i < arguments.length; i++){
                sum += arguments[i];
            }
            return sum;
        }
        alert(funF(1,2,34,5));
    </script>
</head>
<body>

</body>
</html>